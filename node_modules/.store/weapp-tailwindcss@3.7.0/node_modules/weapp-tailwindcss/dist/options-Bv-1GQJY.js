'use strict';

var lruCache = require('lru-cache');
var md5 = require('md5');
var defaults = require('./defaults-CdqzSWsR.js');
var MagicString = require('magic-string');
var _babelGenerate = require('@babel/generator');
var _babelTraverse = require('@babel/traverse');
var parser = require('@babel/parser');
var escape = require('@ast-core/escape');
require('@weapp-core/escape');
var consola = require('consola');
var regex = require('@weapp-core/regex');
var replace = require('./replace.js');
var shared = require('@tailwindcss-mangle/shared');
var postcss = require('postcss');
var index = require('./index-h2-ZMO3S.js');
var path = require('node:path');
var process = require('node:process');
var tailwindcssPatch = require('tailwindcss-patch');
var t = require('@babel/types');
var htmlparser2 = require('htmlparser2');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

function _interopNamespaceCompat(e) {
    if (e && typeof e === 'object' && 'default' in e) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var md5__default = /*#__PURE__*/_interopDefaultCompat(md5);
var MagicString__default = /*#__PURE__*/_interopDefaultCompat(MagicString);
var _babelGenerate__default = /*#__PURE__*/_interopDefaultCompat(_babelGenerate);
var _babelTraverse__default = /*#__PURE__*/_interopDefaultCompat(_babelTraverse);
var postcss__default = /*#__PURE__*/_interopDefaultCompat(postcss);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);
var process__default = /*#__PURE__*/_interopDefaultCompat(process);
var t__namespace = /*#__PURE__*/_interopNamespaceCompat(t);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function createCache(options) {
    const disabled = options === false;
    const hashMap = new Map();
    const instance = new lruCache.LRUCache({
        max: 1024,
        ttl: 0,
        ttlAutopurge: false,
    });
    return {
        hashMap,
        instance,
        hasHashKey(key) {
            return hashMap.has(key);
        },
        getHashValue(key) {
            return hashMap.get(key);
        },
        setHashValue(key, value) {
            return hashMap.set(key, value);
        },
        get(key) {
            return instance.get(key);
        },
        set(key, value) {
            return instance.set(key, value);
        },
        computeHash(message) {
            return md5__default["default"](message);
        },
        calcHashValueChanged(key, hash) {
            const hit = this.getHashValue(key);
            if (hit) {
                this.setHashValue(key, {
                    changed: hash !== hit.hash,
                    hash,
                });
            }
            else {
                this.setHashValue(key, {
                    changed: true,
                    hash,
                });
            }
            return this;
        },
        has(key) {
            return instance.has(key);
        },
        process(key, callback, fallback) {
            return __awaiter(this, void 0, void 0, function* () {
                if (disabled) {
                    const res = yield fallback();
                    if (res) {
                        this.set(res.key, res.source);
                    }
                }
                else {
                    const hit = this.getHashValue(key);
                    if (hit && !hit.changed) {
                        const returnFlag = yield callback();
                        if (returnFlag !== false) {
                            return;
                        }
                    }
                    const res = yield fallback();
                    if (res) {
                        this.set(res.key, res.source);
                    }
                }
            });
        },
    };
}

function decodeUnicode2(input) {
    try {
        return JSON.parse(`"${input}"`);
    }
    catch (_error) {
        return input;
    }
}

function _interopDefaultCompat$1(e) {
    return e && typeof e === 'object' && 'default' in e ? e.default : e;
}
_interopDefaultCompat$1(_babelGenerate__default["default"]);
const traverse = _interopDefaultCompat$1(_babelTraverse__default["default"]);

const logger = consola.createConsola();

function getAstGrep() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const { js } = yield import('@ast-grep/napi');
            return js;
        }
        catch (error) {
            logger.warn('请先安装 `@ast-grep/napi` , 安装完成后再尝试运行！');
            throw error;
        }
    });
}

function isEvalPath(p) {
    if (p.isCallExpression()) {
        const calleePath = p.get('callee');
        return calleePath.isIdentifier() && calleePath.node.name === 'eval';
    }
    return false;
}

const validateFilterRE = /[\w\u00A0-\uFFFF%-?]/;
function isValidSelector(selector = '') {
    return validateFilterRE.test(selector);
}
function splitCode(code, allowDoubleQuotes = false) {
    const splitter = allowDoubleQuotes ? /\s+/ : /\s+|"/;
    return code.split(splitter).filter(element => isValidSelector(element));
}

function replaceHandleValue(str, node, options, ms, offset = 0) {
    const { classNameSet: set, escapeMap, mangleContext: ctx, needEscaped = false, jsPreserveClass, arbitraryValues, always, unescapeUnicode, } = options;
    const allowDoubleQuotes = arbitraryValues === null || arbitraryValues === void 0 ? void 0 : arbitraryValues.allowDoubleQuotes;
    let rawStr = str;
    let needUpdate = false;
    if (unescapeUnicode && rawStr.includes('\\u')) {
        rawStr = decodeUnicode2(rawStr);
    }
    const arr = splitCode(rawStr, allowDoubleQuotes);
    for (const v of arr) {
        if (always || (set && set.has(v) && !(jsPreserveClass === null || jsPreserveClass === void 0 ? void 0 : jsPreserveClass(v)))) {
            let ignoreFlag = false;
            if (Array.isArray(node.leadingComments)) {
                ignoreFlag
                    = node.leadingComments.findIndex(x => x.value.includes('weapp-tw') && x.value.includes('ignore')) > -1;
            }
            if (!ignoreFlag) {
                if (ctx) {
                    rawStr = ctx.jsHandler(rawStr);
                }
                rawStr = rawStr.replace(new RegExp(regex.escapeStringRegexp(v)), replace.replaceJs(v, {
                    escapeMap,
                }));
                needUpdate = true;
            }
        }
    }
    if (needUpdate && typeof node.start === 'number' && typeof node.end === 'number') {
        const start = node.start + offset;
        const end = node.end - offset;
        if (start < end && str !== rawStr) {
            const content = needEscaped ? escape.jsStringEscape(rawStr) : rawStr;
            ms.update(start, end, content);
        }
    }
    return rawStr;
}

const ignoreIdentifier = 'weappTwIgnore';
function astGrepUpdateString(ast, options, ms) {
    return __awaiter(this, void 0, void 0, function* () {
        const js = yield getAstGrep();
        const nodes = ast.findAll(js.kind('string'));
        for (const node of nodes) {
            const range = node.range();
            const text = node.text();
            replaceHandleValue(text.slice(1, -1), {
                end: range.end.index - 1,
                start: range.start.index + 1,
            }, Object.assign(Object.assign({}, options), { unescapeUnicode: true }), ms, 0);
        }
        const templateNodes = ast.findAll(js.kind('template_string'));
        for (const node of templateNodes) {
            const p = node.parent();
            if (p && p.kind() === 'call_expression') {
                const c = p.child(0);
                if (c && c.kind() === 'identifier' && c.text() === ignoreIdentifier) {
                    continue;
                }
            }
            const fragments = node.findAll(js.kind('string_fragment'));
            for (const fragment of fragments) {
                const range = fragment.range();
                const text = fragment.text();
                replaceHandleValue(text, {
                    end: range.end.index,
                    start: range.start.index,
                }, Object.assign(Object.assign({}, options), { unescapeUnicode: true }), ms, 0);
            }
        }
    });
}
function jsHandler(rawSource, options) {
    const ms = new MagicString__default["default"](rawSource);
    let ast;
    try {
        ast = parser.parse(rawSource, options.babelParserOptions);
    }
    catch (error) {
        return {
            code: rawSource,
            error: error,
        };
    }
    const traverseOptions = {
        StringLiteral: {
            enter(p) {
                var _a;
                if (isEvalPath(p.parentPath)) {
                    return;
                }
                const n = p.node;
                replaceHandleValue(n.value, n, Object.assign(Object.assign({}, options), { needEscaped: (_a = options.needEscaped) !== null && _a !== void 0 ? _a : true }), ms, 1);
            },
        },
        TemplateElement: {
            enter(p) {
                if (p.parentPath.isTemplateLiteral()) {
                    if ((p.parentPath.parentPath.isTaggedTemplateExpression()
                        && p.parentPath.parentPath.get('tag').isIdentifier({
                            name: ignoreIdentifier,
                        }))
                        || isEvalPath(p.parentPath.parentPath)) {
                        return;
                    }
                }
                const n = p.node;
                replaceHandleValue(n.value.raw, n, Object.assign(Object.assign({}, options), { needEscaped: false }), ms, 0);
            },
        },
        CallExpression: {
            enter(p) {
                if (isEvalPath(p)) {
                    p.traverse({
                        StringLiteral: {
                            enter(s) {
                                const res = jsHandler(s.node.value, Object.assign(Object.assign({}, options), { needEscaped: false, generateMap: false }));
                                if (res.code) {
                                    const node = s.node;
                                    if (typeof node.start === 'number' && typeof node.end === 'number') {
                                        const start = node.start + 1;
                                        const end = node.end - 1;
                                        if (start < end && s.node.value !== res.code) {
                                            ms.update(start, end, escape.jsStringEscape(res.code));
                                            node.value = res.code;
                                        }
                                    }
                                }
                            },
                        },
                        TemplateElement: {
                            enter(s) {
                                const res = jsHandler(s.node.value.raw, Object.assign(Object.assign({}, options), { generateMap: false }));
                                if (res.code) {
                                    const node = s.node;
                                    if (typeof node.start === 'number' && typeof node.end === 'number') {
                                        const start = node.start;
                                        const end = node.end;
                                        if (start < end && s.node.value.raw !== res.code) {
                                            ms.update(start, end, res.code);
                                            s.node.value.raw = res.code;
                                        }
                                    }
                                }
                            },
                        },
                    });
                }
            },
        },
    };
    traverse(ast, traverseOptions);
    return {
        code: ms.toString(),
        get map() {
            return ms.generateMap();
        },
    };
}
function jsHandlerAsync(rawSource, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const ms = new MagicString__default["default"](rawSource);
        const js = yield getAstGrep();
        let ast;
        try {
            const root = yield js.parseAsync(rawSource);
            ast = root.root();
        }
        catch (_a) {
            return {
                code: rawSource,
            };
        }
        yield astGrepUpdateString(ast, options, ms);
        return {
            code: ms.toString(),
        };
    });
}
function createJsHandler(options) {
    const { mangleContext, arbitraryValues, escapeMap, jsPreserveClass, generateMap, jsAstTool, babelParserOptions } = options;
    function _jsHandler(rawSource, set, options) {
        const opts = defaults.defuOverrideArray(options, {
            classNameSet: set,
            escapeMap,
            arbitraryValues,
            mangleContext,
            jsPreserveClass,
            generateMap,
            jsAstTool,
            babelParserOptions,
        });
        if (opts.jsAstTool === 'ast-grep') {
            return jsHandlerAsync(rawSource, opts);
        }
        return jsHandler(rawSource, opts);
    }
    function sync(rawSource, set, options) {
        const opts = defaults.defuOverrideArray(options, {
            classNameSet: set,
            escapeMap,
            arbitraryValues,
            mangleContext,
            jsPreserveClass,
            generateMap,
            jsAstTool,
            babelParserOptions,
        });
        return jsHandler(rawSource, opts);
    }
    _jsHandler.sync = sync;
    return _jsHandler;
}

function getSelf(x) {
    return x;
}
const defaultMangleContext = {
    rawOptions: false,
    runtimeSet: new Set(),
    classGenerator: new shared.ClassGenerator(),
    filter: shared.defaultMangleClassFilter,
    cssHandler: getSelf,
    jsHandler: getSelf,
    wxmlHandler: getSelf,
};
function useMangleStore() {
    const ctx = Object.assign({}, defaultMangleContext);
    function resetMangle() {
        return Object.assign(ctx, defaultMangleContext);
    }
    function handleValue(rawSource) {
        const arr = splitCode(rawSource);
        for (const x of arr) {
            if (ctx.runtimeSet.has(x)) {
                rawSource = rawSource.replace(new RegExp(regex.escapeStringRegexp(x)), ctx.classGenerator.generateClassName(x).name);
            }
        }
        return rawSource;
    }
    function initMangle(options) {
        var _a;
        ctx.rawOptions = options;
        if (options) {
            if (options === true) {
                options = {
                    classGenerator: {},
                    mangleClassFilter: shared.defaultMangleClassFilter,
                };
            }
            ctx.classGenerator = new shared.ClassGenerator(options.classGenerator);
            ctx.filter = (_a = options.mangleClassFilter) !== null && _a !== void 0 ? _a : shared.defaultMangleClassFilter;
            ctx.jsHandler = (rawSource) => {
                return handleValue(rawSource);
            };
            ctx.cssHandler = (rawSource) => {
                return handleValue(rawSource);
            };
            ctx.wxmlHandler = (rawSource) => {
                return handleValue(rawSource);
            };
        }
    }
    function setMangleRuntimeSet(runtimeSet) {
        const newSet = new Set();
        for (const c of runtimeSet) {
            if (ctx.filter(c)) {
                newSet.add(c);
            }
        }
        ctx.runtimeSet = newSet;
    }
    return {
        mangleContext: ctx,
        resetMangle,
        initMangle,
        setMangleRuntimeSet,
    };
}

function styleHandler(rawSource, options) {
    var _a, _b;
    return postcss__default["default"](index.getPlugins(options))
        .process(rawSource, (_b = (_a = options.postcssOptions) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {
        from: undefined,
    })
        .async();
}
function createStyleHandler(options) {
    return (rawSource, opt) => {
        return styleHandler(rawSource, defaults.defuOverrideArray(opt, options));
    };
}

function createInjectPreflight(options) {
    const result = [];
    if (options && typeof options === 'object') {
        const entries = Object.entries(options);
        for (const [prop, value] of entries) {
            if (value !== false) {
                result.push({
                    prop,
                    value: value.toString(),
                });
            }
        }
    }
    return () => {
        return result;
    };
}

function createTailwindcssPatcher(basedir, cacheDir, supportCustomLengthUnitsPatch) {
    const cache = {};
    if (cacheDir) {
        if (path__default["default"].isAbsolute(cacheDir)) {
            cache.dir = cacheDir;
        }
        else if (basedir) {
            cache.dir = path__default["default"].resolve(basedir, cacheDir);
        }
        else {
            cache.dir = path__default["default"].resolve(process__default["default"].cwd(), cacheDir);
        }
    }
    return new tailwindcssPatch.TailwindcssPatcher({
        cache,
        patch: {
            basedir,
            applyPatches: {
                exportContext: true,
                extendLengthUnits: supportCustomLengthUnitsPatch,
            },
        },
    });
}

var State;
(function (State) {
    State[State["START"] = 0] = "START";
    State[State["TEXT"] = 1] = "TEXT";
    State[State["OPEN_BRACE"] = 2] = "OPEN_BRACE";
    State[State["POTENTIAL_CLOSE"] = 3] = "POTENTIAL_CLOSE";
    State[State["BRACES_COMPLETE"] = 4] = "BRACES_COMPLETE";
})(State || (State = {}));
class Tokenizer {
    constructor() {
        this.reset();
    }
    processChar(char, index) {
        switch (this.state) {
            case State.START:
                if (char === ' ') ;
                else if (char === '{') {
                    this.state = State.OPEN_BRACE;
                    this.bufferStartIndex = index;
                    this.buffer += char;
                    this.expressionBuffer = char;
                    this.expressionStartIndex = index;
                }
                else {
                    this.state = State.TEXT;
                    this.bufferStartIndex = index;
                    this.buffer += char;
                }
                break;
            case State.TEXT:
                if (char === ' ') {
                    this.tokens.push({ start: this.bufferStartIndex, end: index, value: this.buffer, expressions: this.expressions });
                    this.buffer = '';
                    this.expressions = [];
                    this.state = State.START;
                }
                else if (char === '{') {
                    this.buffer += char;
                    this.expressionBuffer = char;
                    this.expressionStartIndex = index;
                    this.state = State.OPEN_BRACE;
                }
                else {
                    this.buffer += char;
                }
                break;
            case State.OPEN_BRACE:
                if (char === '}') {
                    this.buffer += char;
                    this.expressionBuffer += char;
                    this.state = State.POTENTIAL_CLOSE;
                }
                else {
                    this.buffer += char;
                    this.expressionBuffer += char;
                }
                break;
            case State.POTENTIAL_CLOSE:
                if (char === '}') {
                    this.buffer += char;
                    this.expressionBuffer += char;
                    this.expressions.push({
                        start: this.expressionStartIndex,
                        end: index + 1,
                        value: this.expressionBuffer,
                    });
                    this.expressionBuffer = '';
                    this.state = State.BRACES_COMPLETE;
                }
                else {
                    this.buffer += char;
                    this.expressionBuffer += char;
                    this.state = State.OPEN_BRACE;
                }
                break;
            case State.BRACES_COMPLETE:
                if (char === ' ') {
                    this.tokens.push({
                        start: this.bufferStartIndex,
                        end: index,
                        value: this.buffer,
                        expressions: this.expressions,
                    });
                    this.buffer = '';
                    this.expressions = [];
                    this.state = State.START;
                }
                else if (char === '{') {
                    this.expressionStartIndex = index;
                    this.expressionBuffer = char;
                    this.buffer += char;
                    this.state = State.OPEN_BRACE;
                }
                else {
                    this.buffer += char;
                    this.state = State.TEXT;
                }
                break;
            default:
                throw new Error('Unexpected state');
        }
    }
    run(input) {
        for (let i = 0; i < input.length; i++) {
            const char = input[i];
            this.processChar(char, i);
        }
        if (this.buffer.length > 0) {
            this.tokens.push({
                start: this.bufferStartIndex,
                end: input.length,
                value: this.buffer,
                expressions: this.expressions,
            });
        }
        return this.tokens;
    }
    reset() {
        this.state = State.START;
        this.buffer = '';
        this.tokens = [];
        this.bufferStartIndex = 0;
        this.expressionBuffer = '';
        this.expressionStartIndex = 0;
        this.expressions = [];
    }
}

function generateCode(match, options = {}) {
    try {
        const { jsHandler, runtimeSet } = options;
        if (jsHandler && jsHandler.sync && runtimeSet) {
            const { code } = jsHandler.sync(match, runtimeSet);
            return code;
        }
        else {
            const ms = new MagicString__default["default"](match);
            const ast = parser.parseExpression(match);
            traverse(ast, {
                StringLiteral(path) {
                    var _a, _b;
                    if (t__namespace.isMemberExpression(path.parent)) {
                        return;
                    }
                    if (t__namespace.isBinaryExpression(path.parent) && (t__namespace.isConditionalExpression((_a = path.parentPath) === null || _a === void 0 ? void 0 : _a.parent) || t__namespace.isLogicalExpression((_b = path.parentPath) === null || _b === void 0 ? void 0 : _b.parent))) {
                        return;
                    }
                    const n = path.node;
                    replaceHandleValue(n.value, n, {
                        mangleContext: options.mangleContext,
                        escapeMap: options.escapeMap,
                        classNameSet: options.runtimeSet,
                        needEscaped: true,
                        always: true,
                    }, ms, 1);
                },
                noScope: true,
            });
            return ms.toString();
        }
    }
    catch (_a) {
        return match;
    }
}
function handleEachClassFragment(ms, tokens, options = {}) {
    for (const token of tokens) {
        let p = token.start;
        if (token.expressions.length > 0) {
            for (const exp of token.expressions) {
                if (exp.start > token.start && p < exp.start) {
                    ms.update(p, exp.start, replace.replaceJs(ms.slice(p, exp.start), {
                        keepEOL: true,
                        escapeMap: options.escapeMap,
                        mangleContext: options.mangleContext,
                        ignoreHead: p > 0,
                    }));
                }
                const code = `{{${generateCode(exp.value.slice(2, -2), options)}}}`;
                ms.update(exp.start, exp.end, code);
                p = exp.end;
            }
            if (token.end > p) {
                ms.update(p, token.end, replace.replaceJs(ms.slice(p, token.end), {
                    keepEOL: false,
                    escapeMap: options.escapeMap,
                    mangleContext: options.mangleContext,
                    ignoreHead: true,
                }));
            }
        }
        else {
            ms.update(token.start, token.end, replace.replaceJs(token.value, {
                keepEOL: false,
                escapeMap: options.escapeMap,
                mangleContext: options.mangleContext,
                ignoreHead: false,
            }));
        }
    }
}
function templateReplacer(original, options = {}) {
    const ms = new MagicString__default["default"](original);
    const tokenizer = new Tokenizer();
    const tokens = tokenizer.run(ms.original);
    handleEachClassFragment(ms, tokens, options);
    return ms.toString();
}
function regTest(reg, str) {
    reg.lastIndex = 0;
    return reg.test(str);
}
function isPropsMatch(props, attr) {
    if (Array.isArray(props)) {
        for (const prop of props) {
            const res = typeof prop === 'string' ? prop.toLowerCase() === attr.toLowerCase() : regTest(prop, attr);
            if (res) {
                return res;
            }
        }
        return false;
    }
    else if (typeof props === 'string') {
        return props === attr;
    }
    else {
        return regTest(props, attr);
    }
}
function customTemplateHandler(rawSource, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { customAttributesEntities = [], disabledDefaultTemplateHandler, inlineWxs, runtimeSet, jsHandler, } = options !== null && options !== void 0 ? options : {};
        const s = new MagicString__default["default"](rawSource);
        let tag = '';
        const wxsArray = [];
        const parser = new htmlparser2.Parser({
            onopentagname(name) {
                tag = name;
            },
            onattribute(name, value, quote) {
                if (value) {
                    function update() {
                        s.update(parser.startIndex + name.length + 2, parser.endIndex - 1, templateReplacer(value, Object.assign(Object.assign({}, options), { quote })));
                    }
                    if (!disabledDefaultTemplateHandler
                        && (name === 'class' || name === 'hover-class' || name === 'virtualHostClass' || name === 'virtualhostclass')) {
                        update();
                    }
                    for (const [t, props] of customAttributesEntities) {
                        if (t === '*') {
                            if (isPropsMatch(props, name)) {
                                update();
                            }
                        }
                        else if (typeof t === 'string') {
                            if (t === tag && isPropsMatch(props, name)) {
                                update();
                            }
                        }
                        else if (regTest(t, tag) && isPropsMatch(props, name)) {
                            update();
                        }
                    }
                }
            },
            ontext(data) {
                if (inlineWxs && tag === 'wxs') {
                    wxsArray.push({
                        data,
                        endIndex: parser.endIndex + 1,
                        startIndex: parser.startIndex,
                    });
                }
            },
            onclosetag() {
                tag = '';
            },
        }, {
            xmlMode: true,
        });
        parser.write(s.original);
        parser.end();
        for (const { data, endIndex, startIndex } of wxsArray) {
            const { code } = yield jsHandler(data, runtimeSet);
            s.update(startIndex, endIndex, code);
        }
        return s.toString();
    });
}
function createTemplateHandler(options = {}) {
    return (rawSource, opt = {}) => {
        return customTemplateHandler(rawSource, defaults.defuOverrideArray(opt, options));
    };
}

function getOptions(opts) {
    const result = defaults.defuOverrideArray(opts, defaults.defaultOptions, {});
    result.escapeMap = result.customReplaceDictionary;
    const { cssPreflight, customRuleCallback, cssPreflightRange, customAttributes, supportCustomLengthUnitsPatch, arbitraryValues, cssChildCombinatorReplaceValue, inlineWxs, injectAdditionalCssVarScope, jsPreserveClass, disabledDefaultTemplateHandler, cssSelectorReplacement, rem2rpx, cache, jsAstTool, babelParserOptions, postcssOptions, cssRemoveHoverPseudoClass, escapeMap, mangle, tailwindcssBasedir, appType, } = result;
    const cssInjectPreflight = createInjectPreflight(cssPreflight);
    const customAttributesEntities = defaults.isMap(customAttributes)
        ? [...customAttributes.entries()]
        : Object.entries(customAttributes);
    const { initMangle, mangleContext, setMangleRuntimeSet } = useMangleStore();
    initMangle(mangle);
    const styleHandler = createStyleHandler({
        cssInjectPreflight,
        customRuleCallback,
        cssPreflightRange,
        escapeMap,
        mangleContext,
        cssChildCombinatorReplaceValue,
        injectAdditionalCssVarScope,
        cssSelectorReplacement,
        rem2rpx,
        postcssOptions,
        cssRemoveHoverPseudoClass,
    });
    const jsHandler = createJsHandler({
        escapeMap,
        mangleContext,
        arbitraryValues,
        jsPreserveClass,
        generateMap: true,
        jsAstTool,
        babelParserOptions,
    });
    const templateHandler = createTemplateHandler({
        customAttributesEntities,
        escapeMap,
        mangleContext,
        inlineWxs,
        jsHandler,
        disabledDefaultTemplateHandler,
    });
    result.styleHandler = styleHandler;
    result.jsHandler = jsHandler;
    result.templateHandler = templateHandler;
    const twPatcher = createTailwindcssPatcher(tailwindcssBasedir, appType === 'mpx' ? 'node_modules/tailwindcss-patch/.cache' : undefined, supportCustomLengthUnitsPatch !== null && supportCustomLengthUnitsPatch !== void 0 ? supportCustomLengthUnitsPatch : true);
    result.patch = twPatcher.patch;
    result.setMangleRuntimeSet = setMangleRuntimeSet;
    result.cache = cache === undefined || typeof cache === 'boolean' ? createCache(cache) : cache;
    result.twPatcher = twPatcher;
    return result;
}

exports.__awaiter = __awaiter;
exports.getOptions = getOptions;
exports.logger = logger;
