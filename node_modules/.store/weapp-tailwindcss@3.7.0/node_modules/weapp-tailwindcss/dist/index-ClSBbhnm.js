'use strict';

var options = require('./options-Bv-1GQJY.js');
var node_buffer = require('node:buffer');
var stream = require('node:stream');
var index = require('./index-HC-Qkn0i.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var stream__default = /*#__PURE__*/_interopDefaultCompat(stream);

const debug = index.createDebug();
const Transform = stream__default["default"].Transform;
function createPlugins(options$1 = {}) {
    const opts = options.getOptions(options$1);
    const { templateHandler, styleHandler, patch, jsHandler, setMangleRuntimeSet, cache, twPatcher } = opts;
    let runtimeSet = new Set();
    patch === null || patch === void 0 ? void 0 : patch();
    function transformWxss(options$1 = {}) {
        return new Transform({
            objectMode: true,
            transform(file, _encoding, callback) {
                return options.__awaiter(this, void 0, void 0, function* () {
                    runtimeSet = twPatcher.getClassSet();
                    setMangleRuntimeSet(runtimeSet);
                    const error = null;
                    if (file.contents) {
                        const rawSource = file.contents.toString();
                        const hash = cache.computeHash(rawSource);
                        cache.calcHashValueChanged(file.path, hash);
                        yield cache.process(file.path, () => {
                            const source = cache.get(file.path);
                            if (source) {
                                file.contents = node_buffer.Buffer.from(source);
                                debug('css cache hit: %s', file.path);
                            }
                            else {
                                return false;
                            }
                        }, () => options.__awaiter(this, void 0, void 0, function* () {
                            const { css } = yield styleHandler(rawSource, Object.assign({ isMainChunk: true }, options$1));
                            file.contents = node_buffer.Buffer.from(css);
                            debug('css handle: %s', file.path);
                            return {
                                key: file.path,
                                source: css,
                            };
                        }));
                    }
                    callback(error, file);
                });
            },
        });
    }
    function transformJs(options$1 = {}) {
        return new Transform({
            objectMode: true,
            transform(file, _encoding, callback) {
                return options.__awaiter(this, void 0, void 0, function* () {
                    const error = null;
                    if (file.contents) {
                        const rawSource = file.contents.toString();
                        const hash = cache.computeHash(rawSource);
                        cache.calcHashValueChanged(file.path, hash);
                        yield cache.process(file.path, () => {
                            const source = cache.get(file.path);
                            if (source) {
                                file.contents = node_buffer.Buffer.from(source);
                                debug('js cache hit: %s', file.path);
                            }
                            else {
                                return false;
                            }
                        }, () => options.__awaiter(this, void 0, void 0, function* () {
                            const { code } = yield jsHandler(rawSource, runtimeSet, options$1);
                            file.contents = node_buffer.Buffer.from(code);
                            debug('js handle: %s', file.path);
                            return {
                                key: file.path,
                                source: code,
                            };
                        }));
                    }
                    callback(error, file);
                });
            },
        });
    }
    function transformWxml(options$1 = {}) {
        return new Transform({
            objectMode: true,
            transform(file, _encoding, callback) {
                return options.__awaiter(this, void 0, void 0, function* () {
                    const error = null;
                    if (file.contents) {
                        const rawSource = file.contents.toString();
                        const hash = cache.computeHash(rawSource);
                        cache.calcHashValueChanged(file.path, hash);
                        yield cache.process(file.path, () => {
                            const source = cache.get(file.path);
                            if (source) {
                                file.contents = node_buffer.Buffer.from(source);
                                debug('html cache hit: %s', file.path);
                            }
                            else {
                                return false;
                            }
                        }, () => options.__awaiter(this, void 0, void 0, function* () {
                            const code = yield templateHandler(rawSource, Object.assign({ runtimeSet }, options$1));
                            file.contents = node_buffer.Buffer.from(code);
                            debug('html handle: %s', file.path);
                            return {
                                key: file.path,
                                source: code,
                            };
                        }));
                    }
                    callback(error, file);
                });
            },
        });
    }
    return {
        transformWxss,
        transformWxml,
        transformJs,
    };
}

exports.createPlugins = createPlugins;
