'use strict';

var options = require('./options-Bv-1GQJY.js');
var fs = require('node:fs');
var path = require('node:path');
var index = require('./index-h2-ZMO3S.js');
var index$1 = require('./index-HC-Qkn0i.js');
var defaults = require('./defaults-CdqzSWsR.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
var path__default = /*#__PURE__*/_interopDefaultCompat(path);

const debug = index$1.createDebug();
class UnifiedWebpackPluginV5 {
    constructor(options$1 = {}) {
        this.options = options.getOptions(options$1);
        this.appType = this.options.appType;
    }
    apply(compiler) {
        const { mainCssChunkMatcher, disabled, onLoad, onUpdate, onEnd, onStart, styleHandler, patch, templateHandler, jsHandler, setMangleRuntimeSet, runtimeLoaderPath, cache, twPatcher, } = this.options;
        if (disabled) {
            return;
        }
        patch === null || patch === void 0 ? void 0 : patch();
        const { Compilation, sources, NormalModule } = compiler.webpack;
        const { ConcatSource, RawSource } = sources;
        function getClassSet() {
            return twPatcher.getClassSet();
        }
        onLoad();
        const loader = runtimeLoaderPath !== null && runtimeLoaderPath !== void 0 ? runtimeLoaderPath : path__default["default"].resolve(__dirname, './weapp-tw-runtime-loader.js');
        const isExisted = fs__default["default"].existsSync(loader);
        const WeappTwRuntimeAopLoader = {
            loader,
            options: {
                getClassSet,
            },
            ident: null,
            type: null,
        };
        compiler.hooks.compilation.tap(index.pluginName, (compilation) => {
            NormalModule.getCompilationHooks(compilation).loader.tap(index.pluginName, (_loaderContext, module) => {
                if (isExisted) {
                    const idx = module.loaders.findIndex(x => x.loader.includes('postcss-loader'));
                    if (idx > -1) {
                        module.loaders.unshift(WeappTwRuntimeAopLoader);
                    }
                }
            });
            compilation.hooks.processAssets.tapPromise({
                name: index.pluginName,
                stage: Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE,
            }, (assets) => options.__awaiter(this, void 0, void 0, function* () {
                onStart();
                debug('start');
                for (const chunk of compilation.chunks) {
                    if (chunk.id && chunk.hash) {
                        cache.calcHashValueChanged(chunk.id, chunk.hash);
                    }
                }
                const entries = Object.entries(assets);
                const groupedEntries = defaults.getGroupedEntries(entries, this.options);
                const runtimeSet = getClassSet();
                setMangleRuntimeSet(runtimeSet);
                debug('get runtimeSet, class count: %d', runtimeSet.size);
                if (Array.isArray(groupedEntries.html)) {
                    let noCachedCount = 0;
                    for (let i = 0; i < groupedEntries.html.length; i++) {
                        const [file, originalSource] = groupedEntries.html[i];
                        const rawSource = originalSource.source().toString();
                        const hash = cache.computeHash(rawSource);
                        const cacheKey = file;
                        cache.calcHashValueChanged(cacheKey, hash);
                        yield cache.process(cacheKey, () => {
                            const source = cache.get(cacheKey);
                            if (source) {
                                compilation.updateAsset(file, source);
                                debug('html cache hit: %s', file);
                            }
                            else {
                                return false;
                            }
                        }, () => options.__awaiter(this, void 0, void 0, function* () {
                            const wxml = yield templateHandler(rawSource, {
                                runtimeSet,
                            });
                            const source = new ConcatSource(wxml);
                            compilation.updateAsset(file, source);
                            onUpdate(file, rawSource, wxml);
                            debug('html handle: %s', file);
                            noCachedCount++;
                            return {
                                key: cacheKey,
                                source,
                            };
                        }));
                    }
                    debug('html handle finish, total: %d, no-cached: %d', groupedEntries.html.length, noCachedCount);
                }
                if (Array.isArray(groupedEntries.js)) {
                    let noCachedCount = 0;
                    for (let i = 0; i < groupedEntries.js.length; i++) {
                        const [file, originalSource] = groupedEntries.js[i];
                        const cacheKey = defaults.removeExt(file);
                        yield cache.process(cacheKey, () => {
                            const source = cache.get(cacheKey);
                            if (source) {
                                compilation.updateAsset(file, source);
                                debug('js cache hit: %s', file);
                            }
                            else {
                                return false;
                            }
                        }, () => options.__awaiter(this, void 0, void 0, function* () {
                            const rawSource = originalSource.source().toString();
                            const mapFilename = `${file}.map`;
                            const hasMap = Boolean(assets[mapFilename]);
                            const { code, map } = yield jsHandler(rawSource, runtimeSet, {
                                generateMap: hasMap,
                            });
                            const source = new ConcatSource(code);
                            compilation.updateAsset(file, source);
                            onUpdate(file, rawSource, code);
                            debug('js handle: %s', file);
                            noCachedCount++;
                            if (hasMap && map) {
                                const source = new RawSource(map.toString());
                                compilation.updateAsset(mapFilename, source);
                            }
                            return {
                                key: cacheKey,
                                source,
                            };
                        }));
                    }
                    debug('js handle finish, total: %d, no-cached: %d', groupedEntries.js.length, noCachedCount);
                }
                if (Array.isArray(groupedEntries.css)) {
                    let noCachedCount = 0;
                    for (let i = 0; i < groupedEntries.css.length; i++) {
                        const [file, originalSource] = groupedEntries.css[i];
                        const rawSource = originalSource.source().toString();
                        const hash = cache.computeHash(rawSource);
                        const cacheKey = file;
                        cache.calcHashValueChanged(cacheKey, hash);
                        yield cache.process(cacheKey, () => {
                            const source = cache.get(cacheKey);
                            if (source) {
                                compilation.updateAsset(file, source);
                                debug('css cache hit: %s', file);
                            }
                            else {
                                return false;
                            }
                        }, () => options.__awaiter(this, void 0, void 0, function* () {
                            const { css } = yield styleHandler(rawSource, {
                                isMainChunk: mainCssChunkMatcher(file, this.appType),
                            });
                            const source = new ConcatSource(css);
                            compilation.updateAsset(file, source);
                            onUpdate(file, rawSource, css);
                            debug('css handle: %s', file);
                            noCachedCount++;
                            return {
                                key: cacheKey,
                                source,
                            };
                        }));
                    }
                    debug('css handle finish, total: %d, no-cached: %d', groupedEntries.css.length, noCachedCount);
                }
                debug('end');
                onEnd();
            }));
        });
    }
}

exports.UnifiedWebpackPluginV5 = UnifiedWebpackPluginV5;
