'use strict';

var postcssIsPseudoClass = require('@csstools/postcss-is-pseudo-class');
var postcssRem2rpx = require('postcss-rem-to-responsive-pixel');
var selectorParser = require('postcss-selector-parser');
var shared = require('./shared-r_GpWheO.js');
var postcss = require('postcss');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var postcssIsPseudoClass__default = /*#__PURE__*/_interopDefaultCompat(postcssIsPseudoClass);
var postcssRem2rpx__default = /*#__PURE__*/_interopDefaultCompat(postcssRem2rpx);
var selectorParser__default = /*#__PURE__*/_interopDefaultCompat(selectorParser);

const VariablesScopeSymbol = Symbol('VariablesScope');

function createContext() {
    const variablesScopeWeakMap = new WeakMap();
    function isVariablesScope(rule) {
        return variablesScopeWeakMap.get(rule) === VariablesScopeSymbol;
    }
    function markVariablesScope(rule) {
        variablesScopeWeakMap.set(rule, VariablesScopeSymbol);
    }
    return {
        variablesScopeWeakMap,
        isVariablesScope,
        markVariablesScope,
    };
}

const postcssPlugin = 'postcss-weapp-tailwindcss-rename-plugin';
const pluginName = 'weapp-tailwindcss-webpack-plugin';
const vitePluginName = 'vite-plugin-uni-app-weapp-tailwindcss-adaptor';
const WEAPP_TW_REQUIRED_NODE_VERSION = '18.17.0';

function createRuleTransform(rule, options) {
    const { escapeMap, mangleContext, cssSelectorReplacement, cssRemoveHoverPseudoClass } = options;
    const transform = (selectors) => {
        selectors.walk((selector) => {
            if (selector.type === 'universal' && cssSelectorReplacement && cssSelectorReplacement.universal) {
                selector.value = shared.composeIsPseudo(cssSelectorReplacement.universal);
            }
            if (cssRemoveHoverPseudoClass && selector.type === 'selector') {
                const node = selector.nodes.find(x => x.type === 'pseudo' && x.value === ':hover');
                if (node) {
                    selector.remove();
                }
            }
            if (selector.type === 'pseudo'
                && selector.value === ':root'
                && cssSelectorReplacement
                && cssSelectorReplacement.root) {
                selector.value = shared.composeIsPseudo(cssSelectorReplacement.root);
            }
            if (selector.type === 'class') {
                selector.value = shared.internalCssSelectorReplacer(selector.value, {
                    escapeMap,
                    mangleContext,
                });
            }
        });
        if (selectors.length === 0) {
            rule.remove();
        }
    };
    return transform;
}
function getRuleTransformer(rule, options) {
    return selectorParser__default["default"](createRuleTransform(rule, options));
}
function ruleTransformSync(rule, options) {
    const transformer = getRuleTransformer(rule, options);
    return transformer.transformSync(rule, {
        lossless: false,
        updateSelector: true,
    });
}
function isOnlyBeforeAndAfterPseudoElement(node) {
    let b = false;
    let a = false;
    selectorParser__default["default"]((selectors) => {
        selectors.walkPseudos((s) => {
            var _a;
            if (((_a = s.parent) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                if (/^:?:before$/.test(s.value)) {
                    b = true;
                }
                if (/^:?:after$/.test(s.value)) {
                    a = true;
                }
            }
        });
    }).astSync(node);
    return b && a;
}
const fallbackRemove = selectorParser__default["default"]((selectors) => {
    let maybeImportantId = false;
    selectors.walk((selector, idx) => {
        var _a, _b, _c;
        if (idx === 0 && (selector.type === 'id' || selector.type === 'class' || selector.type === 'attribute')) {
            maybeImportantId = true;
        }
        if (selector.type === 'universal') {
            (_a = selector.parent) === null || _a === void 0 ? void 0 : _a.remove();
        }
        if (selector.type === 'pseudo' && selector.value === ':is') {
            if (maybeImportantId && ((_b = selector.nodes[0]) === null || _b === void 0 ? void 0 : _b.type) === 'selector') {
                selector.replaceWith(selector.nodes[0]);
            }
            else {
                (_c = selector.parent) === null || _c === void 0 ? void 0 : _c.remove();
            }
        }
    });
});

const postcssWeappTailwindcssPostPlugin = (options = {
    isMainChunk: true,
}) => {
    const { customRuleCallback, isMainChunk } = options;
    const p = {
        postcssPlugin,
    };
    if (isMainChunk) {
        p.OnceExit = (root) => {
            root.walkRules((rule) => {
                fallbackRemove.transformSync(rule, {
                    updateSelector: true,
                    lossless: false,
                });
                if (rule.selectors.length === 0 || (rule.selectors.length === 1 && rule.selector.trim() === '')) {
                    rule.remove();
                }
            });
        };
    }
    if (typeof customRuleCallback === 'function') {
        p.Rule = (rule) => {
            customRuleCallback(rule, options);
        };
    }
    return p;
};
postcssWeappTailwindcssPostPlugin.postcss = true;

var cssVars = [
    {
        prop: '--tw-border-spacing-x',
        value: '0',
    },
    {
        prop: '--tw-border-spacing-y',
        value: '0',
    },
    {
        prop: '--tw-translate-x',
        value: '0',
    },
    {
        prop: '--tw-translate-y',
        value: '0',
    },
    {
        prop: '--tw-rotate',
        value: '0',
    },
    {
        prop: '--tw-skew-x',
        value: '0',
    },
    {
        prop: '--tw-skew-y',
        value: '0',
    },
    {
        prop: '--tw-scale-x',
        value: '1',
    },
    {
        prop: '--tw-scale-y',
        value: '1',
    },
    {
        prop: '--tw-pan-x',
        value: ' ',
    },
    {
        prop: '--tw-pan-y',
        value: ' ',
    },
    {
        prop: '--tw-pinch-zoom',
        value: ' ',
    },
    {
        prop: '--tw-scroll-snap-strictness',
        value: 'proximity',
    },
    {
        prop: '--tw-gradient-from-position',
        value: ' ',
    },
    {
        prop: '--tw-gradient-via-position',
        value: ' ',
    },
    {
        prop: '--tw-gradient-to-position',
        value: ' ',
    },
    {
        prop: '--tw-ordinal',
        value: ' ',
    },
    {
        prop: '--tw-slashed-zero',
        value: ' ',
    },
    {
        prop: '--tw-numeric-figure',
        value: ' ',
    },
    {
        prop: '--tw-numeric-spacing',
        value: ' ',
    },
    {
        prop: '--tw-numeric-fraction',
        value: ' ',
    },
    {
        prop: '--tw-ring-inset',
        value: ' ',
    },
    {
        prop: '--tw-ring-offset-width',
        value: '0px',
    },
    {
        prop: '--tw-ring-offset-color',
        value: '#fff',
    },
    {
        prop: '--tw-ring-color',
        value: 'rgb(59 130 246 / 0.5)',
    },
    {
        prop: '--tw-ring-offset-shadow',
        value: '0 0 #0000',
    },
    {
        prop: '--tw-ring-shadow',
        value: '0 0 #0000',
    },
    {
        prop: '--tw-shadow',
        value: '0 0 #0000',
    },
    {
        prop: '--tw-shadow-colored',
        value: '0 0 #0000',
    },
    {
        prop: '--tw-blur',
        value: ' ',
    },
    {
        prop: '--tw-brightness',
        value: ' ',
    },
    {
        prop: '--tw-contrast',
        value: ' ',
    },
    {
        prop: '--tw-grayscale',
        value: ' ',
    },
    {
        prop: '--tw-hue-rotate',
        value: ' ',
    },
    {
        prop: '--tw-invert',
        value: ' ',
    },
    {
        prop: '--tw-saturate',
        value: ' ',
    },
    {
        prop: '--tw-sepia',
        value: ' ',
    },
    {
        prop: '--tw-drop-shadow',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-blur',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-brightness',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-contrast',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-grayscale',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-hue-rotate',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-invert',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-opacity',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-saturate',
        value: ' ',
    },
    {
        prop: '--tw-backdrop-sepia',
        value: ' ',
    },
    {
        prop: '--tw-contain-size',
        value: ' ',
    },
    {
        prop: '--tw-contain-layout',
        value: ' ',
    },
    {
        prop: '--tw-contain-paint',
        value: ' ',
    },
    {
        prop: '--tw-contain-style',
        value: ' ',
    },
];

const initialNodes = cssVars.map((x) => {
    return new postcss.Declaration({
        prop: x.prop,
        value: x.value,
    });
});
const PATTERNS = [
    /:not\(template\)\s*[~+]\s*:not\(template\)/.source,
    /:not\(\[hidden\]\)\s*[~+]\s*:not\(\[hidden\]\)/.source,
].join('|');
const BROAD_MATCH_GLOBAL_REGEXP = new RegExp(PATTERNS, 'g');
function testIfVariablesScope(node, count = 2) {
    if (isOnlyBeforeAndAfterPseudoElement(node)) {
        const nodes = node.nodes;
        let c = 0;
        for (const tryTestDecl of nodes) {
            if (tryTestDecl && tryTestDecl.type === 'decl' && tryTestDecl.prop.startsWith('--tw-')) {
                c++;
            }
            if (c >= count) {
                return true;
            }
        }
        return false;
    }
    return false;
}
function testIfTwBackdrop(node, count = 2) {
    if (node.type === 'rule' && node.selector === '::backdrop') {
        const nodes = node.nodes;
        let c = 0;
        for (const tryTestDecl of nodes) {
            if (tryTestDecl && tryTestDecl.type === 'decl' && tryTestDecl.prop.startsWith('--tw-')) {
                c++;
            }
            if (c >= count) {
                return true;
            }
        }
        return false;
    }
    return false;
}
function makePseudoVarRule() {
    const pseudoVarRule = new postcss.Rule({
        selector: '::before,::after',
    });
    pseudoVarRule.append(new postcss.Declaration({
        prop: '--tw-content',
        value: '""',
    }));
    return pseudoVarRule;
}
function remakeCssVarSelector(selectors, options) {
    const { cssPreflightRange, cssSelectorReplacement } = options;
    if (cssPreflightRange === 'all'
        && !selectors.includes(':not(not)')) {
        selectors.push(':not(not)');
    }
    if (cssSelectorReplacement) {
        if (Array.isArray(cssSelectorReplacement.universal)) {
            if (!cssSelectorReplacement.universal.every((x) => {
                return selectors.includes(x);
            })
                && !selectors.includes('*')) {
                selectors.unshift('*');
            }
        }
        else if (typeof cssSelectorReplacement.universal === 'string'
            && !selectors.includes(cssSelectorReplacement.universal)
            && !selectors.includes('*')) {
            selectors.unshift('*');
        }
    }
    return selectors;
}
function remakeCombinatorSelector(selector, cssChildCombinatorReplaceValue) {
    let childCombinatorReplaceValue = 'view + view';
    if (Array.isArray(cssChildCombinatorReplaceValue) && cssChildCombinatorReplaceValue.length > 0) {
        const x = shared.composeIsPseudo(cssChildCombinatorReplaceValue);
        childCombinatorReplaceValue = `${x} + ${x}`;
    }
    else if (typeof cssChildCombinatorReplaceValue === 'string') {
        childCombinatorReplaceValue = cssChildCombinatorReplaceValue;
    }
    return selector.replaceAll(BROAD_MATCH_GLOBAL_REGEXP, childCombinatorReplaceValue);
}
function commonChunkPreflight(node, options) {
    const { ctx, cssChildCombinatorReplaceValue, cssInjectPreflight, injectAdditionalCssVarScope } = options;
    node.selector = remakeCombinatorSelector(node.selector, cssChildCombinatorReplaceValue);
    if (testIfVariablesScope(node)) {
        ctx === null || ctx === void 0 ? void 0 : ctx.markVariablesScope(node);
        node.selectors = remakeCssVarSelector(node.selectors, options);
        node.before(makePseudoVarRule());
        if (typeof cssInjectPreflight === 'function') {
            node.append(...cssInjectPreflight());
        }
    }
    if (injectAdditionalCssVarScope && testIfTwBackdrop(node)) {
        const syntheticRule = new postcss.Rule({
            selectors: ['*', '::after', '::before'],
            nodes: initialNodes,
        });
        syntheticRule.selectors = remakeCssVarSelector(syntheticRule.selectors, options);
        node.before(syntheticRule);
        node.before(makePseudoVarRule());
        if (typeof cssInjectPreflight === 'function') {
            syntheticRule.append(...cssInjectPreflight());
        }
    }
}

function isAtMediaHover(atRule) {
    return (/media\(\s*hover\s*:\s*hover\s*\)/.test(atRule.name)
        || (atRule.name === 'media' && /\(\s*hover\s*:\s*hover\s*\)/.test(atRule.params)));
}
const postcssWeappTailwindcssPrePlugin = (options = {
    isMainChunk: true,
}) => {
    const { isMainChunk } = options;
    const p = {
        postcssPlugin,
        Rule(rule) {
            ruleTransformSync(rule, options);
        },
        AtRule(atRule) {
            if (isAtMediaHover(atRule)) {
                if (atRule.nodes) {
                    atRule.replaceWith(atRule.nodes);
                }
                else {
                    atRule.remove();
                }
            }
        },
    };
    if (isMainChunk) {
        p.Once = (root) => {
            root.walkRules((rule) => {
                commonChunkPreflight(rule, options);
            });
        };
    }
    return p;
};
postcssWeappTailwindcssPrePlugin.postcss = true;

function getPlugins(options) {
    var _a, _b;
    const ctx = createContext();
    options.ctx = ctx;
    const plugins = [
        ...((_b = (_a = options.postcssOptions) === null || _a === void 0 ? void 0 : _a.plugins) !== null && _b !== void 0 ? _b : []),
        postcssWeappTailwindcssPrePlugin(options),
        postcssIsPseudoClass__default["default"]({
            specificityMatchingName: 'weapp-tw-ig',
        }),
    ];
    if (options.rem2rpx) {
        plugins.push(postcssRem2rpx__default["default"](typeof options.rem2rpx === 'object'
            ? options.rem2rpx
            : {
                rootValue: 32,
                propList: ['*'],
                transformUnit: 'rpx',
            }));
    }
    plugins.push(postcssWeappTailwindcssPostPlugin(options));
    return plugins;
}

exports.WEAPP_TW_REQUIRED_NODE_VERSION = WEAPP_TW_REQUIRED_NODE_VERSION;
exports.getPlugins = getPlugins;
exports.pluginName = pluginName;
exports.postcssWeappTailwindcssPostPlugin = postcssWeappTailwindcssPostPlugin;
exports.postcssWeappTailwindcssPrePlugin = postcssWeappTailwindcssPrePlugin;
exports.vitePluginName = vitePluginName;
