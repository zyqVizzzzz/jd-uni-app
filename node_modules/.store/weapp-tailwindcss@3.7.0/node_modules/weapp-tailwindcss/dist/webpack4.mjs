import { g as getOptions, _ as __awaiter } from './options-yXyCFCtr.mjs';
import fs from 'node:fs';
import path from 'node:path';
import { ConcatSource, RawSource } from 'webpack-sources';
import { b as pluginName } from './index-BF8k8rHr.mjs';
import { c as createDebug } from './index-BEIjgKpF.mjs';
import { g as getGroupedEntries, r as removeExt } from './defaults-5A8JI2hW.mjs';
import 'lru-cache';
import 'md5';
import 'magic-string';
import '@babel/generator';
import '@babel/traverse';
import '@babel/parser';
import '@ast-core/escape';
import '@weapp-core/escape';
import 'consola';
import '@weapp-core/regex';
import './replace.mjs';
import './shared-COWjpokr.mjs';
import '@tailwindcss-mangle/shared';
import 'postcss';
import 'node:process';
import 'tailwindcss-patch';
import '@babel/types';
import 'htmlparser2';
import '@csstools/postcss-is-pseudo-class';
import 'postcss-rem-to-responsive-pixel';
import 'postcss-selector-parser';
import 'debug';
import './defu-n46TJT6t.mjs';

const debug = createDebug();
class UnifiedWebpackPluginV4 {
    constructor(options = {}) {
        this.options = getOptions(options);
        this.appType = this.options.appType;
    }
    apply(compiler) {
        const { mainCssChunkMatcher, disabled, onLoad, onUpdate, onEnd, onStart, styleHandler, patch, templateHandler, jsHandler, setMangleRuntimeSet, runtimeLoaderPath, cache, twPatcher, } = this.options;
        if (disabled) {
            return;
        }
        patch === null || patch === void 0 ? void 0 : patch();
        function getClassSet() {
            return twPatcher.getClassSet();
        }
        onLoad();
        const loader = runtimeLoaderPath !== null && runtimeLoaderPath !== void 0 ? runtimeLoaderPath : path.resolve(__dirname, './weapp-tw-runtime-loader.js');
        const isExisted = fs.existsSync(loader);
        const WeappTwRuntimeAopLoader = {
            loader,
            options: {
                getClassSet,
            },
            ident: null,
            type: null,
        };
        compiler.hooks.compilation.tap(pluginName, (compilation) => {
            compilation.hooks.normalModuleLoader.tap(pluginName, (_loaderContext, module) => {
                if (isExisted) {
                    const idx = module.loaders.findIndex(x => x.loader.includes('postcss-loader'));
                    if (idx > -1) {
                        module.loaders.unshift(WeappTwRuntimeAopLoader);
                    }
                }
            });
        });
        compiler.hooks.emit.tapPromise(pluginName, (compilation) => __awaiter(this, void 0, void 0, function* () {
            onStart();
            debug('start');
            for (const chunk of compilation.chunks) {
                if (chunk.id && chunk.hash) {
                    cache.calcHashValueChanged(chunk.id, chunk.hash);
                }
            }
            const assets = compilation.assets;
            const entries = Object.entries(assets);
            const groupedEntries = getGroupedEntries(entries, this.options);
            const runtimeSet = getClassSet();
            setMangleRuntimeSet(runtimeSet);
            debug('get runtimeSet, class count: %d', runtimeSet.size);
            if (Array.isArray(groupedEntries.html)) {
                let noCachedCount = 0;
                for (let i = 0; i < groupedEntries.html.length; i++) {
                    const [file, originalSource] = groupedEntries.html[i];
                    const rawSource = originalSource.source().toString();
                    const hash = cache.computeHash(rawSource);
                    const cacheKey = file;
                    cache.calcHashValueChanged(cacheKey, hash);
                    yield cache.process(cacheKey, () => {
                        const source = cache.get(cacheKey);
                        if (source) {
                            compilation.updateAsset(file, source);
                            debug('html cache hit: %s', file);
                        }
                        else {
                            return false;
                        }
                    }, () => __awaiter(this, void 0, void 0, function* () {
                        const wxml = yield templateHandler(rawSource, {
                            runtimeSet,
                        });
                        const source = new ConcatSource(wxml);
                        compilation.updateAsset(file, source);
                        onUpdate(file, rawSource, wxml);
                        debug('html handle: %s', file);
                        noCachedCount++;
                        return {
                            key: cacheKey,
                            source,
                        };
                    }));
                }
                debug('html handle finish, total: %d, no-cached: %d', groupedEntries.html.length, noCachedCount);
            }
            if (Array.isArray(groupedEntries.js)) {
                let noCachedCount = 0;
                for (let i = 0; i < groupedEntries.js.length; i++) {
                    const [file, originalSource] = groupedEntries.js[i];
                    const cacheKey = removeExt(file);
                    yield cache.process(cacheKey, () => {
                        const source = cache.get(cacheKey);
                        if (source) {
                            compilation.updateAsset(file, source);
                            debug('js cache hit: %s', file);
                        }
                        else {
                            return false;
                        }
                    }, () => __awaiter(this, void 0, void 0, function* () {
                        const rawSource = originalSource.source().toString();
                        const mapFilename = `${file}.map`;
                        const hasMap = Boolean(assets[mapFilename]);
                        const { code, map } = yield jsHandler(rawSource, runtimeSet, {
                            generateMap: hasMap,
                        });
                        const source = new ConcatSource(code);
                        compilation.updateAsset(file, source);
                        onUpdate(file, rawSource, code);
                        debug('js handle: %s', file);
                        noCachedCount++;
                        if (hasMap && map) {
                            const source = new RawSource(map.toString());
                            compilation.updateAsset(mapFilename, source);
                        }
                        return {
                            key: cacheKey,
                            source,
                        };
                    }));
                }
                debug('js handle finish, total: %d, no-cached: %d', groupedEntries.js.length, noCachedCount);
            }
            if (Array.isArray(groupedEntries.css)) {
                let noCachedCount = 0;
                for (let i = 0; i < groupedEntries.css.length; i++) {
                    const [file, originalSource] = groupedEntries.css[i];
                    const rawSource = originalSource.source().toString();
                    const hash = cache.computeHash(rawSource);
                    const cacheKey = file;
                    cache.calcHashValueChanged(cacheKey, hash);
                    yield cache.process(cacheKey, () => {
                        const source = cache.get(cacheKey);
                        if (source) {
                            compilation.updateAsset(file, source);
                            debug('css cache hit: %s', file);
                        }
                        else {
                            return false;
                        }
                    }, () => __awaiter(this, void 0, void 0, function* () {
                        const { css } = yield styleHandler(rawSource, {
                            isMainChunk: mainCssChunkMatcher(file, this.appType),
                        });
                        const source = new ConcatSource(css);
                        compilation.updateAsset(file, source);
                        onUpdate(file, rawSource, css);
                        debug('css handle: %s', file);
                        noCachedCount++;
                        return {
                            key: cacheKey,
                            source,
                        };
                    }));
                }
                debug('css handle finish, total: %d, no-cached: %d', groupedEntries.css.length, noCachedCount);
            }
            debug('end');
            onEnd();
        }));
    }
}

export { UnifiedWebpackPluginV4 };
